Javascript

Variáveis em Javascript:

 Espaços de memória que podem ser definidos e nomeados,
 para armazenarem dados durante a execução do programa.
 Variáveis podem ser alteradas e podem ser de vários tipos
 diferentes. no Javascript, não existe tipagem solida, então
 as variáveis ao serem declaradas uma única vez, podem assumir
 ao longo da execução do programa, diversos tipos diferentes.

 Declaração:

 - 'var': Declara uma variável. Deve ser seguida do nome
   a ser dado para a variável.

 - '=': Sinal de atribuição, usado para atribuir um valor
   a uma variável, sempre da direita para a esquerda.

 Regras ao nomear variáveis:
  
  - Podem começar com letras, '$' ou '_'.
  - Não podem começar com números, mas podem ter números.
  - É possível usar acentos e símbolos.
  - Não podem conter espaços.
  - Não podem ser palavras reservadas.

 Dicas para nomear variáveis:

  - Maiúsculas e minúsculas fazem diferença.
  - Utilize nomes coerentes para as variáveis.


Tipos de dados:

 - 'number': Números, sendo números inteiros ou reais,
   positivos ou negativos.

     - 'Infinity': Número grande demais para o Javscript
        processar.

     - 'NaN': Valor que não considerado um número de fato.

 - 'string': Cadeias de caracteres (textos), sendo obrigatório
   o uso de aspas ('', "" ou ``) para envolver o texto. O texto
   pode ser constituído de caracteres alfanuméricos, símbolos e
   acentos.

 - 'boolean': Tipos lógicos (verdadeiro ou falso), sendo:
    'true' ou 'false'.

 - 'object': Dados do tipo objeto, que possuem uma estrutura
   de dados (arrays, objects, json). Obs: O tipo
   null pode ser considerado um objeto.

 - 'function': Funções, no Javascript, funções podem ser
   armazenadas em variáveis.

 - 'null': Tipo nulo, tipo usado para deixar uma variável
   'vazia'.

 - 'undefined': Valor não existente, não definido, diferente
   do nulo, não é um valor real, mas sim a falta de um valor
   definido para a variável.


Manipulando variaveis:

 Strings:

  - '+': Concatenação entre strings, o conteúdo anterior e posterior ao sinal '+'
    serão aglutinados em uma mesma sentença ou em uma mesma variável.

  - '${}': É possível usar um facilitador para concatenação de strings,
    quando se é necessário interpolar as strings (concatenar entre
    duas strings). Essa técnica é o template string, e para se usar,
    é necessário a string estar entre crase (``).

 Numbers:

  - '+': Suma entre dois números, precisa que ambos os valores
    (antes e depois do sinal) seja numéricos, se apenas um deles
    for string, será feita uma operação de concatenação.


Coversão de Valores:

 Numbers:

  A Classe Number pode ser utilizada para conversão de tipos
  numéricos, possuindo os metodos abaixo:

    - 'parseInt()': Converte um valor númerico em inteiro.
    - 'parseFloat()': Converte um valor númerico em real.

    * É possível utilizar também apenas 'Number()' ao converter,
    o que deixa aberto ao Javascrit optar pela melhor escolha
    no momento da conversão.

 Strings:

  A Classe String pode ser usada para conversão de strings, sendo
  possível utiliza-la diretamente: 'String()'.


Propriedades e métodos do tipo String:

  - 'length': Atributo que retorna número de caracteres de
    uma string.

  - 'toUpperCase()': Altera a string, jogando todos os caracters
    alfabéticos para o maiúsculo.

  - 'toLowerCase()': Altera a string, jogando todos os caracters
    alfabéticos para o minúsculo.

  - 'toLocaleString()': Localiza a string no contexto regional,
    permitindo configurações de acordo com país ou nacionalidade
    desejado.

Propriedades e métodos do tipo Number:

  - 'toFixed()': Altera as casas decimais do número, podendo ser
    passando o número de casas desejadas.


Operadores:

 - Aritméticos

   - '+': Soma, traz o resultado de soma entre dois operandos.

   - '-': Subtração, traz o resultado de soma entre dois operandos.

   - '*': Multiplicação, traz o resultado de multiplicação entre
     dois operandos.

   - '/': Divisão, traz o resultado da divisão real entre dois
     operandos.

   - '%': Divisão inteira, traz o resto da visião inteira entre
     dois operandos.

   - '**': Potenciação, traz o resultado da potência entre dois
     operandos (à esquerda do '**' a base e a direita o expoente).


   * Todos os operadores aritméticos do Javascript são binários,
     ou seja, trabalham com dois operandos.

   * Ao criar sentenças matemáticas, é possível envolver blocos
     artiméticos em '()' para indicar um calculo prioritário.

   * Assim como na matemática, a ordem das operações dentro de um
     sentença aritmética é dada seguindo uma ordem de precedência.
     No caso do Javascript, a ordem de precedência é:

       1 - '()';
       2 - '**';
       3 - '*', '/', '%';
       4 - '+', '-';

 - Atribuição

   - '=': Atribuição de valor.

   - Auto Atribuição:

     Atribui à variável o valor resultante da operação/expressão
     matemática seguinte tendo o valor atual da própria variável
     como operando.

     - '+=': Auto Soma.

     - '-=': Auto Subtração.

     - '*=': Auto multiplicação.

     - '/=': Auto divisão.

     - '**=': Auto potenciação.

     - '%=': Auto divisão inteira (resto).

   - Incremento/decremento:

     Incrementa ou descresce o valor da variável em 1.

     - '++': Incrementa 1 à variável.

     - '--': Decrementa 1 à variável.

     * Ao utilizar os operadores de incremento/decremento
       antes da variável, a operação é realizada no exato
       momento e já altera o valor na expressão corrente.
       Enquanto ao utilizar os operadores depois da variável,
       a operação é realizada após o termino da expressão
       corrente.

 - Relacionais

   Retorna um valor lógico (boolean) resultante da comparação
   entre dois valores númericos ou variáveis, seguindo sempre
   da esquerda para a drireita.

   - '>': Maior que.

   - '<': Menor que.

   - '>=': Maior que ou igual a.

   - '<=': Menor que ou igual a.

   - '==': Igual a (somente em valor).

   - '===': Igual a (em valor e também em tipo).

   - '!=': Diferente de (somente em valor).

   - '!==': Diferente de (em valor e também em tipo).
  

   * É possível utilizar também operadores relacionais
     em strings.

   * O operador '===' também é conhecido como operador
     de indentidade ou igualdade restrita, pois só retorna
     true se os dois valores forem exatamente os mesmos, tanto
     em valor quanto em tipo.
     
   * O operador '!==' também segue a mesma linha de raciocínio,
     ele é chamado de diferença ou desigualdade restrita.

   * Os operadores relacionais não possuem ordem de precedência
     entre si, prevalenscendo a ordem da expressão, sempre da
     esquerda para a direita.
  
   * Ao utilizar operadores relacionais juntamente com
     operadores aritméticos, os aritméticos serão resolvidos
     antes de haver a comparação.

 - Lógicos

   Operadores usados para trabalhar com valores lógicos (boolean).
   Usados em expressões onde o resultado de comparações aritméticas
   ou strings precisam ser comparadas com outros resultados lógicos.
   Eses operadores comparam valores como 'true' e 'false' e retornam
   da mesma forma, valores 'true' ou 'false'.

   - '!': Negação ('Não' lógico - comparador unário)
      Retorna true se o valor comparado for false e retorna 
      false se o valor comparado for true.

   - '&&': Conjunção ('E' lógico - comparador binário).
     Retorna o resultado da comparação entre dois valores boolean,
     sejam true ou false. Onde retornará true se ambos os valores
     resultantes forem também true. E retornará false se apenas
     um dos valores não for true.

   - '||': Disjunção ('Ou' Lógico - comparador binário).
     Retorna o resultado da comparação entre dois valores boolean,
     sejam true ou false. Onde retornará true se apenas um dos
     valores for true, mesmo que o otro seja false. E retornará
     false, apenas quando ambos os valores são false.


   * Ao utilizar os operadores lógicos, exite uma ordem de
     precedência, da seguinte forma:

     1 - '!';
     2 - '&&';
     3 - '||';

   * Ao utilizar os operadores lógicos juntamente com operadores
     relacionais, os operadores relacionais serão resolvidos antes
     dos operadores lógicos.


 - Ordem de precedência:

   Em expressões onde são utilizados os operadores Artiméticos,
   Relacionais e Lógicos, a ordem de precedência para a execussão
   será a seguinte:

   1 - Aritméticos.
   2 - Relacionais.
   3 - Lógicos.

   * Sempre considerando  a ordem de precedência de cada operador
     individualmente em suas famílias.

 - Ternário

   Expressão de teste lógico. Onde se pode definir um teste e
   o valor a ser retornado em caso positivo (true) e o valor a
   ser retornado em caso negativo (false).

   - 'teste ? caso positivo (true) : caso negativo (false)'.

   * Dentro da area de teste da expressão ternária, é possível
     utilizar qualquer um dos operadores listados acima.


Funções:

 Bloco de código destacado do resto do código, onde é possível
 criar uma lógica dedicada para algum processo específico.
 
 As funções uma vez declaradas, podem ser acessadas em qualquer
 parte do mesmo arquivo em que estão, respeitando o escopo corrente.

 As funções podem usar argumentos externos para usar dentro do
 seu código, que são passados no momento da chamada da função,
 conhecidos como parametros.

 Uma função pode executar o seu código e realizar suas alterações
 dentro do seu proprio escopo e encerrar seu processo, ou pode
 em dado momento, retornar algum dado ou resposta para quem a
 chamou, o que é conhecido como retorno de função.

 Declaração:

   function action() {
    'código interno da função'
   };

   function action2(param) {
    'código interno da função'
   }

 Chamada:

   action();
   action2(5);


Condições:

 São estruturas dentro do código que definem o fluxo de
 execução das instruções do código.
 
 Uma estrutura condicional se baseia em valores lógicos (boolean) 
 para definir um desvio condicional que define que um bloco de 
 código será ou não executado ou qual bloco de código será
 executado.

 A primeira estrutura condicional é o 'if', que desvia o fluxo
 para o bloco de código primário quando a condição for
 atendida (valo lógico true).
 
 Se a condição não for atendida, o bloco de código não será executado.
 Nesse caso o fluxo pode seguir para os próximos processos, ou pode
 desviar para uma outra estrutura, que é o 'else'. O else quando
 definido, desviará o fluxo de código para outro bloco quando a
 condição do 'if' não for satisfeita, ou seja, o seu bloco de código
 será executado quando o valor lógico for false.

 Exemplo:

 * if('condição') {
    'bloco de código' - executado quando condição for true.
   }
   'fluxo normal do programa'.

 * if('condição) {
    'bloco de código' - Executado quando condição for true.

   } else {
    'bloco de código' - executado quando condição for false.

   }
   'fluxo normal do programa'.


 Quando existe a necessidade de multiplas condições, ou seja
 não apenas um condição para true e uma para false, mas também
 uma terceira ou mais condições. Esse caso é chamado de condição
 aninhada.

 A estrutura aninhada ocorre dentro do else, como outros 'if' que
 terão seus proprios requisitos condicionais para ser true ou false.

 Exemplo:

 * if ('condição') {
    'bloco de código' - Executado quando condição for true.

   } else {

    if ('condição') {

      'bloco de código' - Executado quando condição principal for
      false, mas a condição do if atual for true.
    }

   }

   'fluxo normal do programa'.


 É possível declarar uma estrutura condicional aninhada sem precisar
 criar um bloco dentro do else, para isso, existe a estrutura 'else if'.

 Exemplo:

 * if ('condição) {
    'bloco de código' - Executado quando condição for true.
  
   } else if ('condição') {
    'bloco de código' - Executado quando a primeira condição é false.

   } else if ('condição') {
    'block de código' - Executado quando a condição anterior é false.

   } else {
    'bloco de código' - Exectado quando nenhum condição for true.
   }

   'fluxo normal do programa'.

 Existe uma outra estrutura condicional, usada principalmente para
 trabalhar com condicionais fixas. Essa estrutura é o 'switch'.
 Diferente do if/else-if/else vistos anteriormente, o switch é
 declarado de maneira diferente. Onde será avaliada um valor e
 será criada um bloco de código para trabalhar com as opções
 possíveis para esse valor (opções fixas) ou também 'casos' possíveis.
 
 Exemplo:

 * switch(expressão) {
    case 'valor1': 'código quando o valor for o caso 1'.

    case 'valor2': 'código quando o valor for o caso 2'

    default: 'código quando o valor não for nenhum dos casos'.
 }
 
 'fluxo normal do programa'.


 Para cada 'case' dentro do switch, é obrigatório o uso de
 uma palavra reservada 'break', para encerrar o código do
 case e sair da estrutura do switch.

 Exemplo:

 * switch(expressão) {
    case 'valor1': 'código quando o valor for o caso 1'.
    break;

    case 'valor2': 'código quando o valor for o caso 2'
    break;

    default: 'código quando o valor não for nenhum dos casos'.
 }
 
 'fluxo normal do programa'.


Repetições (laços de repetição)

 Estrutura que permite a execução de um bloco de código
 em repetição, sendo possível definir o número de repetições
 e as condicionais para que a repetição inicie, para que ela
 termine e também de que forma as repetições serão encadeadas.

 - A condição precisa ser sempre verdadeira (true) para que
 a repetição se inicie. Ao iniciar, é executado o bloco de
 código e após a execução, o js volta a ler novamente a condição
 e seguir o mesmo processo enquanto a condição for verdadeira.
 No momento que a condição é false, o bloco de código não é
 executado e o js sai do loop e continua o código aoós a
 estrutura de repetição.

 - 'while()' - Estrutura de repetição em que executa o
   bloco de código enquanto a condição for true.

   Exemplo:

     while(true) {
      'bloco de código' - Executado pois a condição é true.
     }

     while(false) {
      'bloco de código' - Não é executado pois a condição é false.
     }

  - 'do-while()' - esrutura de repetição em que executa uma
    vez o bloco de código antes de checar a condição. Se a
    condição for true, continua executando o bloco de código,
    senão, sai do loop.

    Exemplo:

     do {
      'bloco de código' - Executado uma vez antes de checar a
       condição.
     } while ('true); - Como a condição é true, volta para executar
     novamente o bloco de cpodigo e então testar novamente a
     condição.

     do {
      'bloco de código' - Executado uma vez antes de checar a
       condição.
     } while(false) - Como a condição é false, não volta para
     executar o bloco de código e sai para o fluxo normal do
     programa.
     